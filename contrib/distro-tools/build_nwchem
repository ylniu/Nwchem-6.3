#!/bin/bash
export RELEASE=6.3
function usage()
{
   cat <<EOF

 Build NWChem
 ============

 This script compiles an executable of NWChem aiming to make this as automatic
 as possible. While the script tries to guess as many configuration options 
 possible one can always override this by setting appropriate environment 
 variables (see section ENVIRONMENT VARIABLES). On most platforms it should
 be enough to load modules for the compilers, and MPI libraries.

 The script should be run in the top level NWChem directory (e.g. nwchem-6.1.1,
 put differently the top level directory contains the directories src and
 contrib) and takes at most one argument. This way you can use it to build
 NWChem by simply invoking 

    ./contrib/distro-tools/build_nwchem

 and similarly clean everything up by invoking

    ./contrib/distro-tools/build_nwchem realclean

 running

    ./contrib/distro-tools/build_nwchem help

 produces this text.


 ENVIRONMENT VARIABLES
 ---------------------

 The script will not override any user set environment variables. This allows
 you to specify setting by hand that the script guesses wrong. Below is a list
 of the environment variables the script tries to guess and what they 
 control:

 NWCHEM_TOP        -- The top level NWChem directory.
                      Example: /home/mydir/nwchem-6.1.1.

 NWCHEM_TARGET     -- The platform for which NWChem should be compiled. It
                      should end in "64" if the machine provides a 64-bit
                      platform. 
                      Examples: BGP, LINUX, LINUX64, MACX, MACX64, IBM, IBM64.

 NWCHEM_MODULES    -- A list of code modules your NWChem build should include. 
                      Examples: "all", "qm", "qmandpw md", "all python".

 NWCHEM_EXECUTABLE -- The full name of the NWChem executable.
                      Example: /home/mydir/nwchem-6.1.1/bin/LINUX64/nwchem.

 NWCHEM_VERSION    -- If set a routine listing the version numbers of all
                      source code files will be included in the file
                      util_version.F. The generation of this routine used to 
                      be the default but now the code prints SVN revision
                      numbers which in essence makes the old approach obsolete.
                      The only place when the old approach is still useful is
                      on machines without SVN. For those cases this environment
                      variable may be set (any value will do) and the version
                      routine will be generated.
                      Examples: y, yes.

 ARMCI_NETWORK     -- The communication infra-structure the ARMCI library in
                      the GA should use. 
                      Examples: DCMFMPI, GEMINI, PORTALS, OPENIB, MPI-MT.

 MPI_F90           -- The Fortran compiler matching your MPI library.
                      Examples: gfortran, ftn, ifort, xlf, pgf90.

 MPI_CC            -- The C compiler matching your MPI library.
                      Examples: gcc, cc, icc, xlc, pgcc.

 MPI_CXX           -- The C++ compiler matching your MPI library.
                      Examples: g++, CC, iCC, pgCC.

 MPI_INCLUDE       -- The path at which the MPI include files live.
                      Example: -I/usr/mpi/include.

 MPI_LIB           -- The path at which the MPI libraries live.
                      Example: -L/usr/mpi/lib.

 LIBMPI            -- The MPI libraries to link against.
                      Example: "-lmpichf90 -lmpichf90 -lmpich -lopa".

 BLASOPT           -- Specifies the BLAS, LAPACK and maybe even ScaLAPACK
                      libraries in a generic way. This setting overrides
                      BLAS_LIB, LAPACK_LIB, and SCALAPACK_LIB as various 
                      makefiles will use this regardless of anything.

 BLAS_LIB          -- The BLAS linear algebra library to use.
                      Examples: -lblas, -latlas, -lacml, -lmkl.

 BLAS_SIZE         -- The size of the integers in bytes that the BLAS interface
                      uses.
                      Examples: 4, 8.

 LAPACK_LIB        -- The LAPACK linear algebra library to use.
                      Examples: -llapack, -lacml, -lmkl.

 LAPACK_SIZE       -- The size of the integers in bytes that the LAPACK
                      interface uses.
                      Examples: 4, 8.

 SCALAPACK_LIB     -- The ScaLAPACK linear algebra library to use.
                      Examples: -lscalapack, -lacml, -lmkl.

 SCALAPACK_SIZE    -- The size of the integers in bytes that the ScaLAPACK
                      interface uses.
                      Examples: 4, 8.

 Notes:

 The environment variables BLAS_SIZE, LAPACK_SIZE and SCALAPACK_SIZE all have 
 to have the same value, either 4 or 8, to successfully build NWChem.

 Huub van Dam
 \$Id: build_nwchem 24245 2013-05-17 19:52:20Z d3y133 $
EOF
}
# Compiler flags to try. First we try -q64 for 64 bit capabilities on IBM 
# machines. If that fails we try the empty flag. On IBM that will default to
# generate 32 bit executables, on other platforms we typically get what the
# hardware is capable of.
declare -a LIST_COMPFLAGS
LIST_COMPFLAGS=( '-q64' ' ' )
export LIST_COMPFLAGS
#
declare -a LIST_LINLIBS
LIST_LINLIBS=( '-lmkl' '-lacml' '-lcxml' '-lscs' '-lcomplib.sgimath' '-lsunmath' '-latlas' '-lgoto2' '-lgoto' '-lessl' '-lscalapack' '-llapack' '-lcblas' '-lblas' '-lf77blas' )
export LIST_LINLIBS
function get_mpi_include ()
{
   # This shell function extracts the MPI include file directories
   # and returns them as a list for a compile line.
   # E.g.: /usr/include -I/usr/local/include
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -link-info
     #
     inlist="`mpif90 -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-I*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
#  len=`expr "${outlist}" : ' -I*'`
#  if [ ${len} -ge 3 ] ; then
#    outlist="${outlist:3}"
#  fi
   echo ${outlist}
}
function get_mpi_link ()
{
   # This shell function extracts the MPI library file directories
   # and returns them as a list for a link line.
   # E.g.: /usr/lib -L/usr/local/lib
   #
   # most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # Otherwise try -link-info
     #
     inlist="`mpif90 -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get link info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-L*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
#  len=`expr "${outlist}" : ' -L*'`
#  if [ ${len} -ge 3 ] ; then
#    outlist="${outlist:3}"
#  fi
   echo ${outlist}
}
function get_mpi_lib ()
{
   # This shell function extracts the MPI libraries
   # and returns them as a list for a link line.
   # E.g.: -lmpich
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -link-info
     #
     inlist="`mpif90 -link-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get library info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   for word in ${inlist} ; do
      len=`expr "${word}" : '-l*'`
      if [ ${len} -ge 2 ] ; then
        outlist="${outlist} ${word}"
      fi
   done
   echo ${outlist}
}
function get_mpi_fortran ()
{
   # This shell function extracts the fortran compiler
   # and returns its name as a list for a compile line.
   # E.g.: gfortran
   #
   # Most support -show
   #
   inlist="`mpif90 -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpif90 -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpif90 -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpif90" > /dev/stderr
     exit 1
   fi
   outlist=""
   length=${#LIST_COMPFLAGS[*]}
   for word in ${inlist} ; do
      echo "c23456 test program">/tmp/$$.f
      echo "       program test">>/tmp/$$.f
      echo "       write(6,'(\"hello world\")')">>/tmp/$$.f
      echo "       end">>/tmp/$$.f
      word=`basename ${word}`
      indx=0
      while [ "${indx}" -lt "${length}" ] ; do
         flags=${LIST_COMPFLAGS[$indx]}
         ((indx++))
         ${word} ${flags} -o /tmp/$$.x /tmp/$$.f
         result=$?
         if [ ${result} -eq 0 ] ; then
           /tmp/$$.x > /dev/null
           result=$?
           if [ ${result} -eq 0 ] ; then
             echo ${word}
             rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.f
             return 0
           fi
         fi
      done
   done
   rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.f
   echo "ERROR: could not find a valid Fortran compiler" > /dev/stderr
   exit 1
}
function get_mpi_cc ()
{
   # This shell function extracts the C compiler
   # and returns its name as a list for a compile line.
   # E.g.: gcc
   #
   # Most support -show
   #
   inlist="`mpicc -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpicc -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpicc -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpicc" > /dev/stderr
     exit 1
   fi
   outlist=""
   length=${#LIST_COMPFLAGS[*]}
   for word in ${inlist} ; do
      echo "#include <stdio.h>">/tmp/$$.c
      echo "int main(void){">>/tmp/$$.c
      echo "    printf(\"hello world\n\");">>/tmp/$$.c
      echo "    return 0;">>/tmp/$$.c
      echo "}">>/tmp/$$.c
      word=`basename ${word}`
      indx=0
      while [ "${indx}" -lt "${length}" ] ; do
         flags=${LIST_COMPFLAGS[$indx]}
         ((indx++))
         ${word} ${flags} -o /tmp/$$.x /tmp/$$.c
         result=$?
         if [ ${result} -eq 0 ] ; then
           /tmp/$$.x > /dev/null
           result=$?
           if [ ${result} -eq 0 ] ; then
             echo ${word}
             rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.c
             return 0
           fi
         fi
      done
   done
   rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.c
   echo "ERROR: could not find a valid C compiler" > /dev/stderr
   exit 1
}
function get_mpi_cxx ()
{
   # This shell function extracts the C++ compiler
   # and returns its name as a list for a compile line.
   # Because there are some case insensitive file systems we
   # have to try mpic++ and mpicxx first because if they are
   # not found mpiCC will find the C-compiler wrapper script
   # on those systems.
   # E.g.: g++
   #
   # Most support -show
   #
   inlist="`mpicxx -show`"
   result=$?
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpicxx -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpicxx -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     inlist="`mpic++ -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # Most support -show
     #
     inlist="`mpiCC -show`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # OPENMPI supports -showme
     #
     inlist="`mpiCC -showme`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     #
     # MPICH2 and MVAPICH2 support -compile-info
     #
     inlist="`mpiCC -compile-info`"
     result=$?
   fi
   if [ ${result} -ne 0 ] ; then
     echo "ERROR: cannot get compile info from mpiCC" > /dev/stderr
     exit 1
   fi
   outlist=""
   length=${#LIST_COMPFLAGS[*]}
   for word in ${inlist} ; do
      echo "#include <iostream>">/tmp/$$.cpp
      echo "int main(void) {">>/tmp/$$.cpp
      echo "    std::cout << \"hello world\n\";">>/tmp/$$.cpp
      echo "    return 0;">>/tmp/$$.cpp
      echo "}">>/tmp/$$.cpp
      word=`basename ${word}`
      indx=0
      while [ "${indx}" -lt "${length}" ] ; do
         flags=${LIST_COMPFLAGS[$indx]}
         ((indx++))
         ${word} ${flags} -o /tmp/$$.x /tmp/$$.cpp
         result=$?
         if [ ${result} -eq 0 ] ; then
           /tmp/$$.x > /dev/null
           result=$?
           if [ ${result} -eq 0 ] ; then
             echo ${word}
             rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.cpp
             return 0
           fi
         fi
      done
   done
   rm -f /tmp/$$.x /tmp/$$.o /tmp/$$.cpp
   echo "ERROR: could not find a valid C++ compiler" > /dev/stderr
   exit 1
}
function get_config_value()
{
   # This function extracts the value of a setting in config.status.
   # The approach is to simply grep the key on the config.status file.
   # We expect to get 1 line in response, and we return whatever appears
   # after the equals sign.
   key=$1
   line=`grep $key ${NWCHEM_TOP}/src/tools/build/config.status`
   line=${line/*=/}
   line=${line/#\"/}
   line=${line/%\"/}
   echo ${line}
}
function config_is_set()
{
   # This function retrieves the value of a seting in config.status according
   # to the key specified. It then checks the length of the result. If
   # the result was "" (length <= 0) then it was not set, otherwise it is.
   key=$1
   result=`get_config_value $key`
   if [ ${#result} -gt 0 ] ; then
     value=0
   else
     value=1
   fi
   echo ${value}
}
function get_blas_lib()
{
   # This function tries to find a BLAS library. Any library found must allow
   # a Fortran program that calls BLAS routines to compile, link and run.
   # The first library that matches these criteria is returned.
   fcomp=$1
   blasopt="$2"
   if [ ${#fcomp} -eq 0 ] ; then
       echo
       return
   fi
   lib=""
   length=${#LIST_LINLIBS[*]}
   indx=0
   while [ "${indx}" -lt "${length}" ] ; do
     candidate="${LIST_LINLIBS[${indx}]}"
     ((indx++))
     # echo "blas: trying ${candidate}" > /dev/stderr
     if [ "${blasopt}" != "0" ] ; then
       candidate="${blasopt}"
     fi
     if [ ${#lib} -eq 0 ] ; then
       echo "      program testblas" > testblas$$.f
       echo "      implicit none" >> testblas$$.f
       echo "      double precision a, b, c" >> testblas$$.f
       echo "      integer*8 n, m, k" >> testblas$$.f
       echo "      integer*8 lda" >> testblas$$.f
       echo "      a = 1.0d0" >> testblas$$.f
       echo "      b = 2.0d0" >> testblas$$.f
       echo "      c = 0.0d0" >> testblas$$.f
       echo "      lda = 1" >> testblas$$.f
       echo "      n = 1" >> testblas$$.f
       echo "      m = 1" >> testblas$$.f
       echo "      k = 1" >> testblas$$.f
       echo "      call dgemm('n','n',m,n,k,1.0d0,a,lda,b,lda,0.0d0,c,lda)" >> testblas$$.f
       echo "      end" >> testblas$$.f
       $fcomp -o testblas$$.x testblas$$.f ${candidate} > /dev/null
       result=$?
       if [ ${result} -eq 0 ] ; then
         ./testblas$$.x > /dev/null
         result=$?
         if [ ${result} -eq 0 ] ; then
           # This library worked so we will go with this
           lib="${candidate}"
           # echo "blas: found ${lib}" > /dev/stderr
         fi
         rm -f ./testblas$$.x
       fi
       rm -f ./testblas$$.f
     fi
   done
   if [ ${#lib} -eq 0 ] ; then
     # We have not found anything suitable
     echo ${lib}
     return 1
   fi
   echo ${lib}
}
function get_blas_integer()
{
   #
   # Establish whether the BLAS library found uses integer*4 or integer*8.
   #
   fcomp=$1
   blaslib=$2
   echo "      program testblasint" > ./testblas$$.f
   echo "      implicit none" >> ./testblas$$.f
   echo "      integer*8 typecast" >> ./testblas$$.f
   echo "      integer*4 data(2)" >> ./testblas$$.f
   echo "      double precision a, b, c" >> ./testblas$$.f
   echo "      integer*8 n, m, k, ld" >> ./testblas$$.f
   echo "      integer*8 two" >> ./testblas$$.f
   echo "      external  typecast" >> ./testblas$$.f
   echo "      logical   obigendian" >> ./testblas$$.f
   echo "      a = 0.5d0" >> ./testblas$$.f
   echo "      b = 2.0d0" >> ./testblas$$.f
   echo "      c = 0.0d0" >> ./testblas$$.f
   echo "      data(1) = 0" >> ./testblas$$.f
   echo "      data(2) = 1" >> ./testblas$$.f
   echo "      obigendian = (1.eq.typecast(data))" >> ./testblas$$.f
   echo "      two = 2" >> ./testblas$$.f
   echo "      if (obigendian) then" >> ./testblas$$.f
   echo "        n  = two**32+two**0" >> ./testblas$$.f
   echo "        m  = two**32+two**1" >> ./testblas$$.f
   echo "        k  = two**32+two**2" >> ./testblas$$.f
   echo "        ld = two**32" >> ./testblas$$.f
   echo "      else" >> ./testblas$$.f
   echo "        n  = two**32+two**0" >> ./testblas$$.f
   echo "        m  = two**33+two**0" >> ./testblas$$.f
   echo "        k  = two**34+two**0" >> ./testblas$$.f
   echo "        ld = two**0" >> ./testblas$$.f
   echo "      endif" >> ./testblas$$.f
   echo "      call dgemm('n','n',m,n,k,1.0d0,a,ld,b,ld,0.0d0,c,ld)" >> ./testblas$$.f
   echo "      if (abs(c-1.0d0).lt.1.0d-10) then" >> ./testblas$$.f
   echo "        write(*,'(a)')'4'" >> ./testblas$$.f
   echo "      else" >> ./testblas$$.f
   echo "        write(*,'(a)')'8'" >> ./testblas$$.f
   echo "      endif" >> ./testblas$$.f
   echo "      end" >> ./testblas$$.f
   echo "      integer*8 function typecast(input)" >> ./testblas$$.f
   echo "      implicit none" >> ./testblas$$.f
   echo "      integer*8 input" >> ./testblas$$.f
   echo "      typecast = input" >> ./testblas$$.f
   echo "      return" >> ./testblas$$.f
   echo "      end" >> ./testblas$$.f
   ${fcomp} -o ./testblas$$.x ./testblas$$.f ${blaslib}
   result=`./testblas$$.x`
   status=$?
   if [ ${status} -ne 0 ] ; then
     result="8"
   else
     out=`expr "${result}" : '.*\(4\)'`
     if [ "${out}" == "4" ] ; then
       result="4"
     else
       out=`expr "${result}" : '.*\(8\)'`
       if [ "${out}" == "8" ] ; then
         result="8"
       else
         result="0"
       fi
     fi
   fi
   rm -f ./testblas$$.f
   rm -f ./testblas$$.x
   echo ${result}
}
function get_lapack_lib()
{
   # This function tries to find a LAPACK library. Any library found must allow
   # a Fortran program that calls LAPACK routines to compile, link and run.
   # The first library that matches these criteria is returned.
   fcomp=$1
   if [ ${#fcomp} -eq 0 ] ; then
       echo
       return
   fi
   blas=$2
   blasopt=$3
   lib=""
   length=${#LIST_LINLIBS[*]}
   indx=0
   while [ "${indx}" -lt "${length}" ] ; do
     candidate="${LIST_LINLIBS[${indx}]}"
     ((indx++))
     # echo "lapack: trying ${candidate}" > /dev/stderr
     if [ "${blasopt}" != "0" ] ; then
       candidate="${blasopt}"
     fi
     if [ ${#lib} -eq 0 ] ; then
       echo "      program testlapack" > testlapack$$.f
       echo "      implicit none" >> testlapack$$.f
       echo "      double precision a, w, work" >> testlapack$$.f
       echo "      integer*8 n" >> testlapack$$.f
       echo "      integer*8 lda" >> testlapack$$.f
       echo "      integer*8 lwork, info" >> testlapack$$.f
       echo "      a = 1.0d0" >> testlapack$$.f
       echo "      lda = 1" >> testlapack$$.f
       echo "      n = 1" >> testlapack$$.f
       echo "      lwork = 1" >> testlapack$$.f
       echo "      call dsyev('n','u',n,a,lda,w,work,lwork,info)" >> testlapack$$.f
       echo "      end" >> testlapack$$.f
       $fcomp -o testlapack$$.x testlapack$$.f ${candidate} ${blas} > /dev/null
       result=$?
       if [ ${result} -eq 0 ] ; then
         ./testlapack$$.x > /dev/null
         result=$?
         if [ ${result} -eq 0 ] ; then
           # This library worked so we will go with this
           lib="${candidate}"
           # echo "lapack: found ${lib}" > /dev/stderr
         fi
         rm -f ./testlapack$$.x
       fi
       rm -f ./testlapack$$.f
     fi
   done
   if [ ${#lib} -eq 0 ] ; then
     # We have not found anything suitable
     echo ${lib}
     return 1
   fi
   echo ${lib}
}
function get_lapack_integer()
{
   # This function works out whether the LAPACK library uses 
   # an integer*4 or integer*8 interface.
   fcomp=$1
   blaslapack=$2
   echo "      program testlapackint" > ./testlapack$$.f
   echo "      implicit none" >> ./testlapack$$.f
   echo "      integer*8 typecast" >> ./testlapack$$.f
   echo "      integer*4 data(2)" >> ./testlapack$$.f
   echo "      double precision a, w, ww(10)" >> ./testlapack$$.f
   echo "      integer*8 n, ld, lw" >> ./testlapack$$.f
   echo "      integer*8 two" >> ./testlapack$$.f
   echo "      integer*8 info" >> ./testlapack$$.f
   echo "      external  typecast" >> ./testlapack$$.f
   echo "      logical   obigendian" >> ./testlapack$$.f
   echo "      a = 0.5d0" >> ./testlapack$$.f
   echo "      w = 1.0d0" >> ./testlapack$$.f
   echo "      data(1) = 0" >> ./testlapack$$.f
   echo "      data(2) = 1" >> ./testlapack$$.f
   echo "      obigendian = (1.eq.typecast(data))" >> ./testlapack$$.f
   echo "      two = 2" >> ./testlapack$$.f
   echo "      info = 0" >> ./testlapack$$.f
   echo "      if (obigendian) then" >> ./testlapack$$.f
   echo "        n  = two**32+two**0" >> ./testlapack$$.f
   echo "        lw = 10*two**32+two**0" >> ./testlapack$$.f
   echo "        ld = two**32" >> ./testlapack$$.f
   echo "      else" >> ./testlapack$$.f
   echo "        n  = two**32+two**0" >> ./testlapack$$.f
   echo "        lw = two**32+10*two**0" >> ./testlapack$$.f
   echo "        ld = two**0" >> ./testlapack$$.f
   echo "      endif" >> ./testlapack$$.f
   echo "      call dsyev('n','u',n,a,ld,w,ww,lw,info)" >> testlapack$$.f
   echo "      if (info.eq.0) then" >> ./testlapack$$.f
   echo "        write(*,'(a)')'4'" >> ./testlapack$$.f
   echo "      else" >> ./testlapack$$.f
   echo "        write(*,'(a)')'8'" >> ./testlapack$$.f
   echo "      endif" >> ./testlapack$$.f
   echo "      end" >> ./testlapack$$.f
   echo "      integer*8 function typecast(input)" >> ./testlapack$$.f
   echo "      implicit none" >> ./testlapack$$.f
   echo "      integer*8 input" >> ./testlapack$$.f
   echo "      typecast = input" >> ./testlapack$$.f
   echo "      return" >> ./testlapack$$.f
   echo "      end" >> ./testlapack$$.f
   $fcomp -o testlapack$$.x testlapack$$.f ${blaslapack} > /dev/null
   result=`./testlapack$$.x`
   status=$?
   if [ ${status} -ne 0 ] ; then
     result=8
   elif [ "${result}" != "4" ] ; then
     result=8
   fi
   rm -f ./testlapack$$.x
   rm -f ./testlapack$$.f
   echo ${result}
}
function get_scalapack_lib()
{
   # This function tries to find a ScaLAPACK library. Any library found must allow
   # a Fortran program that calls ScaLAPACK routines to compile, link and run.
   # The first library that matches these criteria is returned.
   fcomp=$1
   lapackblas=$2
   blasopt=$3
   if [ ${#fcomp} -eq 0 ] ; then
       echo
       return
   fi
   lib=""
   length=${#LIST_LINLIBS[*]}
   indx=0
   while [ "${indx}" -lt "${length}" ] ; do
     candidate="${LIST_LINLIBS[${indx}]}"
     ((indx++))
     # echo "lapack: trying ${candidate}" > /dev/stderr
     if [ "${blasopt}" != "0" ] ; then
       candidate="${blasopt}"
     fi
     if [ ${#lib} -eq 0 ] ; then
       echo "      program testscalapack" > testscalapack$$.f
       echo "      implicit none" >> testscalapack$$.f
       echo "      double precision a, b" >> testscalapack$$.f
       echo "      integer*8 n" >> testscalapack$$.f
       echo "      integer*8 ia,ja,ib,jb, info" >> testscalapack$$.f
       echo "      integer*8 desca(1),descb(1),ipiv(2)" >> testscalapack$$.f
       echo "      a = 2.0d0" >> testscalapack$$.f
       echo "      b = 1.0d0" >> testscalapack$$.f
       echo "      ia = 1" >> testscalapack$$.f
       echo "      ja = 1" >> testscalapack$$.f
       echo "      ib = 1" >> testscalapack$$.f
       echo "      jb = 1" >> testscalapack$$.f
       echo "      n = 1" >> testscalapack$$.f
       echo "      call pdgetrs('n',n,n,a,ia,ja,desca,ipiv,b,ib,jb,descb,info)" >> testscalapack$$.f
       echo "      end" >> testscalapack$$.f
       $fcomp -o testscalapack$$.x testscalapack$$.f ${candidate} ${lapackblas} > /dev/null
       result=$?
       if [ ${result} -eq 0 ] ; then
         ./testscalapack$$.x > /dev/null
         result=$?
         if [ ${result} -eq 0 ] ; then
           # This library worked so we will go with this
           lib="${candidate}"
           # echo "lapack: found ${lib}" > /dev/stderr
         fi
         rm -f ./testscalapack$$.x
       fi
       rm -f ./testscalapack$$.o
       rm -f ./testscalapack$$.f
     fi
   done
   if [ ${#lib} -eq 0 ] ; then
     # We have not found anything suitable
     echo ${lib}
     return 1
   fi
   echo ${lib}
}
function get_scalapack_integer()
{
   # This function works out whether the LAPACK library uses 
   # an integer*4 or integer*8 interface.
   fcomp=$1
   blaslapacksca=$2
   echo "      program testscalapack" > testscalapack$$.f
   echo "      implicit none" >> testscalapack$$.f
   echo "      double precision a, b" >> testscalapack$$.f
   echo "      integer*8 n" >> testscalapack$$.f
   echo "      integer*8 ia,ja,ib,jb" >> testscalapack$$.f
   echo "      integer*8 id(9),ip(10)" >> testscalapack$$.f
   echo "      integer*8 info" >> testscalapack$$.f
   echo "      integer*8 typecast" >> testscalapack$$.f
   echo "      logical   integer8" >> testscalapack$$.f
   echo "      external  typecast,integer8" >> testscalapack$$.f
   echo "      integer*4 data(2)" >> testscalapack$$.f
   echo "      a = 1.0d0" >> testscalapack$$.f
   echo "      b = 1.0d0" >> testscalapack$$.f
   echo "      do ia = 1, 9" >> testscalapack$$.f
   echo "        id(ia) = -1" >> testscalapack$$.f
   echo "      enddo" >> testscalapack$$.f
   echo "      ia = 0" >> testscalapack$$.f
   echo "      ib = 0" >> testscalapack$$.f
   echo "      data(1) = -1" >> testscalapack$$.f
   echo "      data(2) = -1" >> testscalapack$$.f
   echo "      ja = typecast(data)" >> testscalapack$$.f
   echo "      jb = typecast(data)" >> testscalapack$$.f
   echo "      data(2) = 0" >> testscalapack$$.f
   echo "      data(1) = 8" >> testscalapack$$.f
   echo "      n = typecast(data)" >> testscalapack$$.f
   echo "      data(1) = 999999" >> testscalapack$$.f
   echo "      data(2) = 999999" >> testscalapack$$.f
   echo "      info = typecast(data)" >> testscalapack$$.f
   echo "      call pdgetrs('n',n,n,a,ia,ja,id,ip,b,ib,jb,id,info)" >> testscalapack$$.f
   echo "      if (integer8(data,info)) then" >> testscalapack$$.f
   echo "        write(*,'(a)')'8'" >> ./testscalapack$$.f
   echo "      else" >> ./testscalapack$$.f
   echo "        write(*,'(a)')'4'" >> ./testscalapack$$.f
   echo "      endif" >> ./testscalapack$$.f
   echo "      end" >> testscalapack$$.f
   echo "      integer*8 function typecast(input)" >> ./testscalapack$$.f
   echo "      implicit none" >> testscalapack$$.f
   echo "      integer*8 input" >> ./testscalapack$$.f
   echo "      typecast = input" >> ./testscalapack$$.f
   echo "      return" >> ./testscalapack$$.f
   echo "      end" >> ./testscalapack$$.f
   echo "      logical function integer8(data,input)" >> ./testscalapack$$.f
   echo "      implicit none" >> testscalapack$$.f
   echo "      integer*4 input(2),data(2)" >> ./testscalapack$$.f
   echo "      integer8 = (input(1).ne.data(1)).and.(input(2).ne.data(2))" >> ./testscalapack$$.f
   echo "      return" >> ./testscalapack$$.f
   echo "      end" >> ./testscalapack$$.f
   $fcomp -o testscalapack$$.x testscalapack$$.f ${blaslapacksca} > /dev/null
   result=`./testscalapack$$.x`
   out=`expr "${result}" : '.*\(4\)'`
   if [ "${out}" != "4" ] ; then
     out=`expr "${result}" : '.*\(8\)'`
     if [ "${out}" != "8" ] ; then
       out="0"
     fi
   fi
   rm -f ./testscalapack$$.x
   rm -f ./testscalapack$$.o
   rm -f ./testscalapack$$.f
   echo ${out}
}
function get_pointer_size ()
{
   # This shell function works out whether pointers
   # are 8- or 4-bytes on this platform. This function
   # expects to be given the compiler to use as an input.
   declare -a list
   ccomp=$1
   output=""
   length=${#LIST_COMPFLAGS[*]}
   echo "#include <stdio.h>">/tmp/$$.c
   echo "int main(void){">>/tmp/$$.c
   echo "    int* ptr = NULL;">>/tmp/$$.c
   echo "    int size = sizeof(ptr);">>/tmp/$$.c
   echo "    printf(\"%d\n\",size);">>/tmp/$$.c
   echo "    return 0;">>/tmp/$$.c
   echo "}">>/tmp/$$.c
   indx=0
   while [ "${indx}" -lt "${length}" ] ; do
     flags=${LIST_COMPFLAGS[$indx]}
     ((indx++))
     ${ccomp} ${flags} -o /tmp/$$.x /tmp/$$.c
     result=$?
     if [ ${result} -eq 0 ] ; then
       output=`/tmp/$$.x`
       result=$?
       if [ ${result} -eq 0 ] ; then
         echo ${output}
         rm -f  /tmp/$$.c /tmp/$$.o /tmp/$$.x
         return 0
       fi
     fi
   done
   rm -f  /tmp/$$.c /tmp/$$.o /tmp/$$.x
   echo "ERROR: could not establish the pointer size" > /dev/stderr
   exit 1
}
#
# Decide what we need to do here
#
option=$1
if [ "$option" == "help" ] ; then
  usage
  exit 1
elif [ "$option" == "" ] ; then
  echo > /dev/null
elif [ "$option" == "realclean" ] ; then
  echo > /dev/null
elif [ "$option" == "python" ] ; then
  echo > /dev/null
elif [ "$option" == "python64" ] ; then
  echo > /dev/null
else
  usage
  exit 1
fi
#
# Check whether NWCHEM_TOP is set to something sensible...
#
if [ ${#RELEASE} -ne 0 ] ; then
  if [ ${#NWCHEM_TOP} -ne 0 ] ; then
    echo "${NWCHEM_TOP}" | grep "${RELEASE}" > /dev/null
    status=$?
    if [ ${status} -ne 0 ] ; then
      export NWCHEM_TOP=${NWCHEM_TOP}-${RELEASE}
    fi
  fi
fi
#
# See if we can detect which platform we are on.
# This is most relevant to the various BlueGene platforms as they are a complete
# package, i.e. if you know you are on a BlueGene/P then all required settings
# are prescribed. This is not the case on other platforms.
#
echo "=== figure out Network, MPI, and LinAlg libraries ==="
if [ -f /bgsys/drivers/ppcfloor/comm/sys/include/dcmf.h ] ; then
  #
  # This is a BlueGene/P machine
  #
  if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
    export NWCHEM_TARGET=BGP
  fi
  if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
    export ARMCI_NETWORK=DCMFMPI
  fi
  if [ ${#MSG_COMMS} -eq 0 ] ; then
    export MSG_COMMS=DCMFMPI
  fi
  if [ ${#USE_MPI} -eq 0 ] ; then
    export USE_MPI=y
  fi
  if [ ${#BGCOMPILERS} -eq 0 ] ; then
    export BGCOMPILERS=/bgsys/drivers/ppcfloor/gnu-linux/bin
  fi
  if [ ${#BGP_INSTALLDIR} -eq 0 ] ; then
    export BGP_INSTALLDIR=/bgsys/drivers/ppcfloor
  fi
  if [ ${#BGP_RUNTIMEPATH} -eq 0 ] ; then
    export BGP_RUNTIMEPATH=/bgsys/drivers/ppcfloor/runtime
  fi
  if [ ${#ARMCIDRV} -eq 0 ] ; then
    export ARMCIDRV=${BGP_INSTALLDIR}
  fi
  if [ ${#BGDRIVER} -eq 0 ] ; then
    export BGDRIVER=${ARMCIDRV}
  fi
  if [ ${#MPI_LIB} -eq 0 ] ; then
    export MPI_LIB=${BGDRIVER}/comm/lib
  fi
  if [ ${#MPI_INCLUDE} -eq 0 ] ; then
    export MPI_INCLUDE=${BGDRIVER}/comm/include
  fi
  if [ ${#BGMLMPI_INCLUDE} -eq 0 ] ; then
    export BGMLMPI_INCLUDE=${MPI_INCLUDE}
  fi
  if [ ${#LIBMPI} -eq 0 ] ; then
    export LIBMPI="-L${MPI_LIB} -lfmpich_.cnk -lmpich.cnk -ldcmf.cnk -ldcmfcoll.cnk -lpthread -lrt -L${BGP_RUNTIMEPATH}/SPI -lSPI.cna"
  fi
  if [ ${#MPI_F90} -eq 0 ] ; then
    export MPI_F90=mpixlf77
  fi
  if [ ${#MPI_CC} -eq 0 ] ; then
    export MPI_CC=mpixlc
  fi
  if [ ${#MPI_CXX} -eq 0 ] ; then
    export MPI_CXX=mpixlcxx
  fi
fi
if [ -f /bgsys/drivers/ppcfloor/comm/sys/include/pami.h ] ; then
  #
  # This is a BlueGene/Q machine
  #
  if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
    export NWCHEM_TARGET=BGQ
  fi
  if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
    export ARMCI_NETWORK=MPI-MT
  fi
  if [ ${#MSG_COMMS} -eq 0 ] ; then
    export MSG_COMMS=MPI
  fi
  if [ ${#USE_MPI} -eq 0 ] ; then
    export USE_MPI=y
  fi
  if [ ${#BGCOMPILERS} -eq 0 ] ; then
    export BGCOMPILERS=/bgsys/drivers/ppcfloor/gnu-linux/bin
  fi
  if [ ${#BGQ_INSTALLDIR} -eq 0 ] ; then
    export BGQ_INSTALLDIR=/bgsys/drivers/ppcfloor
  fi
  if [ ${#BGQ_RUNTIMEPATH} -eq 0 ] ; then
    export BGQ_RUNTIMEPATH=/bgsys/drivers/ppcfloor/runtime
  fi
  if [ ${#ARMCIDRV} -eq 0 ] ; then
    export ARMCIDRV=${BGQ_INSTALLDIR}
  fi
  if [ ${#BGDRIVER} -eq 0 ] ; then
    export BGDRIVER=${ARMCIDRV}
  fi
  if [ ${#MPI_LIB} -eq 0 ] ; then
    export MPI_LIB=${BGDRIVER}/comm/lib
  fi
  if [ ${#MPI_INCLUDE} -eq 0 ] ; then
    export MPI_INCLUDE=${BGDRIVER}/comm/include
  fi
  if [ ${#BGMLMPI_INCLUDE} -eq 0 ] ; then
    export BGMLMPI_INCLUDE=${MPI_INCLUDE}
  fi
  if [ ${#LIBMPI} -eq 0 ] ; then
    export LIBMPI="-L${MPI_LIB} -lfmpich_.cnk -lmpich.cnk -ldcmf.cnk -ldcmfcoll.cnk -lpthread -lrt -L${BGQ_RUNTIMEPATH}/SPI -lSPI.cna"
  fi
  if [ ${#MPI_F90} -eq 0 ] ; then
    export MPI_F90=mpixlf77_r
  fi
  if [ ${#MPI_CC} -eq 0 ] ; then
    export MPI_CC=mpixlc_r
  fi
  if [ ${#MPI_CXX} -eq 0 ] ; then
    export MPI_CXX=mpixlcxx_r
  fi
fi
#
# End of BlueGene stuff
#
if [ ${#NWCHEM_TOP} -eq 0 ] ; then
  export NWCHEM_TOP=`pwd`
fi
if [ ${#NWCHEM_MODULES} -eq 0 ] ; then
  export NWCHEM_MODULES="all"
fi
if [ ${#LARGE_FILES} -eq 0 ] ; then
  # Apparently LARGE_FILES is important so that the code can use files that
  # are larger than 2GB. Also nobody has been able to give me a good reason
  # why it should not be turned on in some cases. So I'll just hardwire it to
  # be turned on always. Of course if it should always be turned on nowadays
  # then why are we keeping this option?
  export LARGE_FILES=y
fi
export LDOPTIONS=" "
#export USE_SUBGROUPS=y # disables parallel diag, do not set for release
#export DEV_GA=y        # do not set this for the release
#export USE_GPROF=y
#
# Now we try and guess the network on the machine.
# The default is MPI-MT.
#
if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
  #
  # Do we have a CRAY Gemini interconnect?
  # /opt/cray present then we are probably on a Cray machine
  # /opt/cray/*/gemini present then we have a Gemini interconnect
  # This is at least the situation on Hopper @ NERSC.
  #
  if [ -d /opt/cray ] ; then
    GEMINIDIRS=`find /opt/cray -name gemini`
    if [ ${#GEMINIDIRS} -ne 0 ] ; then
      echo "This machine is a Cray with a GEMINI interconnect"
      echo "Please ensure you have the following modules loaded:"
      echo "  module load ntk"
      echo "  module load onesided"
      echo "Module ntk provides numatoolkit.h and libnumatoolkit,"
      echo "whereas module onesided provides onesided.h and libonesided."
      echo "Use the following command to check which modules are loaded:"
      echo "  module list"
      # There seems to be a Gemini interconnect on this Cray machine
      export ARMCI_NETWORK="DMAPP"
      if [ ${#USE_MPI} -eq 0 ] ; then
        export USE_MPI=y
      fi
      if [ ${#MPI_F90} -eq 0 ] ; then
        export MPI_F90=ftn
      fi
      if [ ${#MPI_CC} -eq 0 ] ; then
        export MPI_CC=cc
      fi
      if [ ${#MPI_CXX} -eq 0 ] ; then
        export MPI_CXX=CC
      fi
    fi
  fi
fi
if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
  #
  # This test is stolen from GASNET
  # /dev/ukbride present then we are probably on a Cray XT machine
  # /proc/portals/meminfo present then this machine has Cray Portals
  #
  if [ -f /proc/portals/meminfo ] ; then
    # There seems to be a portals infrastructure on this machine
    export ARMCI_NETWORK="PORTALS"
    if [ ${#USE_MPI} -eq 0 ] ; then
      export USE_MPI=y
    fi
    if [ ${#MPI_F90} -eq 0 ] ; then
      export MPI_F90=ftn
    fi
    if [ ${#MPI_CC} -eq 0 ] ; then
      export MPI_CC=cc
    fi
    if [ ${#MPI_CXX} -eq 0 ] ; then
      export MPI_CXX=CC
    fi
    if [ ${#MA_USE_ARMCI_MEM} -eq 0 ] ; then
      export MA_USE_ARMCI_MEM=1
    fi
  fi
fi
if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
  if [ -d /dev/infiniband ] ; then
    # There seems to be an infiniband network on this machine
    export ARMCI_NETWORK="OPENIB"
    if [ ${#USE_MPI} -eq 0 ] ; then
      export USE_MPI=y
    fi
  fi
fi
if [ "${ARMCI_NETWORK}" == "OPENIB" ] ; then
  if [ ${#IB_LIB} -eq 0 ]; then
    if [ -f /usr/lib64/libibverbs.so ] ; then
      export IB_LIB="/usr/lib64"
    elif [ -f /usr/lib/libibverbs.so ] ; then
      export IB_LIB="/usr/lib"
    elif [ -f /usr/lib64/libibverbs.a ] ; then
      export IB_LIB="/usr/lib64"
    elif [ -f /usr/lib/libibverbs.a ] ; then
      export IB_LIB="/usr/lib"
    elif [ -f /usr/local/ofed/lib64/libibverbs.so ] ; then
      export IB_LIB="/usr/local/ofed/lib64"
    elif [ -f /usr/local/ofed/lib/libibverbs.so ] ; then
      export IB_LIB="/usr/local/ofed/lib"
    elif [ -f /usr/local/ofed/lib64/libibverbs.a ] ; then
      export IB_LIB="/usr/local/ofed/lib64"
    elif [ -f /usr/local/ofed/lib/libibverbs.a ] ; then
      export IB_LIB="/usr/local/ofed/lib"
    else
      echo "ERROR: Infiniband library files not in expected location"
      exit 1
    fi
  fi
  if [ ${#IB_INCLUDE} -eq 0 ]; then
    if [ -d /usr/include/infiniband ] ; then
      export IB_INCLUDE="/usr/include"
    elif [ -d /usr/local/ofed/include/infiniband ] ; then
      export IB_INCLUDE="/usr/local/ofed/include"
    else
      echo "ERROR: Infiniband include files not in expected location"
      exit 1
    fi
  fi
  if [ ${#IB_LIB_NAME} -eq 0 ]; then
    export IB_LIB_NAME="-libverbs"
  fi
fi
if [ ${#OLD_GA} -eq 0 ] ; then
  if [ ${#ARMCI_NETWORK} -eq 0 ] ; then
    echo "#include \"stdio.h\""                                         >  ./mpi_threads$$.c
    echo "#include \"mpi.h\""                                           >> ./mpi_threads$$.c
    echo "int main(int argc, char **argv)"                              >> ./mpi_threads$$.c
    echo "{"                                                            >> ./mpi_threads$$.c
    echo "   int required = MPI_THREAD_MULTIPLE;"                       >> ./mpi_threads$$.c
    echo "   int provided;"                                             >> ./mpi_threads$$.c
    echo "   int result;"                                               >> ./mpi_threads$$.c
    echo "   result = MPI_Init_thread(&argc,&argv,required,&provided);" >> ./mpi_threads$$.c
    echo "   if (provided == MPI_THREAD_MULTIPLE) {"                    >> ./mpi_threads$$.c
    echo "     printf(\"multithreaded\n\");"                            >> ./mpi_threads$$.c
    echo "   } else if (provided == MPI_THREAD_SERIALIZED) {"           >> ./mpi_threads$$.c
    echo "     printf(\"serialthreaded\n\");"                           >> ./mpi_threads$$.c
    echo "   } else if (provided == MPI_THREAD_FUNNELED) {"             >> ./mpi_threads$$.c
    echo "     printf(\"funnelthreaded\n\");"                           >> ./mpi_threads$$.c
    echo "   } else if (provided == MPI_THREAD_SINGLE) {"               >> ./mpi_threads$$.c
    echo "     printf(\"singlethreaded\n\");"                           >> ./mpi_threads$$.c
    echo "   } else {"                                                  >> ./mpi_threads$$.c
    echo "     result = 1;"                                             >> ./mpi_threads$$.c
    echo "   }"                                                         >> ./mpi_threads$$.c
    echo "   result = result || MPI_Finalize();"                        >> ./mpi_threads$$.c
    echo "   return result;"                                            >> ./mpi_threads$$.c
    echo "}"                                                            >> ./mpi_threads$$.c
    # On some systems there is no mpicc to compile an MPI code, so we need to
    # try some more options.
    which mpicc
    result=$?
    if [ ${result} -eq 0 ] ; then
      mpicc -o ./mpi_threads$$.x ./mpi_threads$$.c
      result=$?
    else
      which mpxlc_r
      result=$?
      if [ ${result} -eq 0 ] ; then
        mpxlc_r -o ./mpi_threads$$.x ./mpi_threads$$.c
        result=$?
      fi
    fi
    if [ ${result} -ne 0 ] ; then
      # Compiling with multi-threaded support did not work, so no hope here
      export ARMCI_NETWORK=SOCKETS
    else
      if [ ${#USE_MPI} -eq 0 ] ; then
        export USE_MPI=y
      fi
      output=`./mpi_threads$$.x`
      result=$?
      if [ ${result} -ne 0 ] ; then
        # Testing multi-threaded support did not work, so we have only two options
        # If the experimental GA branch is being used we can use the MPI 
        # two-sided interface at this point, otherwise our only option might be
        # to hope for the best (essentially assuming that the sysops did not let
        # us run the mpi_threads tests which might happen on a computer service).
        if [ "x${EXP_GA}" != "x" ] ; then
          # use two-sided over MPI
          export ARMCI_NETWORK="MPI_TS"
        else
          # hope and pray...
          export ARMCI_NETWORK="MPI-MT"
        fi
      else
        if [ "${output}" == "multithreaded" ] ; then
          # We have confirmed multi-threaded support!
          export ARMCI_NETWORK="MPI-MT"
        fi
      fi
    fi
    rm -f ./mpi_threads$$.x ./mpi_threads$$.c
  fi
# else
#   OLD_GA is set but GA-4-3 does not implement MPI-MT or MPI_TS
fi
#
# Below we have to realize that EXPORT is a command. Hence if we use
#   EXPORT DUMMY=`ls`
#   status=$?
# then status will be set to the exit code of the EXPORT command. If we
# want the exit code from the ls command we need to write
#   DUMMY=`ls`
#   status=$?
#   EXPORT DUMMY
#
if [ ${#MPI_INCLUDE} -eq 0 ] ; then
  MPI_INCLUDE=`get_mpi_include`
  if [ $? -ne 0 ] ; then
    unset MPI_INCLUDE
  fi
fi
if [ ${#MPI_LIB} -eq 0 ] ; then
  MPI_LIB=`get_mpi_link`
  if [ $? -ne 0 ] ; then
    unset MPI_LIB
  fi
fi
if [ ${#LIBMPI} -eq 0 ] ; then
  LIBMPI=`get_mpi_lib`
  if [ $? -ne 0 ] ; then
    unset LIBMPI
  fi
fi
if [ ${#MPI_F90} -eq 0 ] ; then
  MPI_F90=`get_mpi_fortran`
  if [ $? -ne 0 ] ; then
    unset MPI_F90
  fi
fi
if [ ${#MPI_CC} -eq 0 ] ; then
  MPI_CC=`get_mpi_cc`
  if [ $? -ne 0 ] ; then
    unset MPI_CC
  fi
fi
if [ ${#MPI_CXX} -eq 0 ] ; then
  MPI_CXX=`get_mpi_cxx`
  if [ $? -ne 0 ] ; then
    unset MPI_CXX
  fi
fi
export MPI_INCLUDE
export MPI_LIB
export LIBMPI
#
# If USE_MPI is not set at this stage do one more test to see if we have MPI.
# If we have MPI set USE_MPI to "y" otherwise leave USE_MPI as is.
# This is a catch all approach needed in case USE_MPI was not set but e.g.
# ARMCI_NETWORK is. In that case ARMCI_NETWORK is not going to be detected and
# associated USE_MPI initialization will not happen either. Therefore we need
# to test USE_MPI separately (as opposed to conditionally on other settings).
#
if [ ${#USE_MPI} -eq 0 ] ; then
  echo "#include <mpi.h>" > /tmp/$$.c
  echo "int main(int argc, char *argv[]){" >> /tmp/$$.c
  echo "   MPI_Init(&argc,&argv);" >> /tmp/$$.c
  echo "   MPI_Finalize();" >> /tmp/$$.c
  echo "}" >> /tmp/$$.c
  mpicc -o /tmp/$$.x /tmp/$$.c
  if [ $? -eq 0 ] ; then
    export USE_MPI=y
  fi
  rm -f /tmp/$$.x /tmp/$$.c
fi
#
# Work out whether this is a 32- or 64-bit platform
# We need a C-compiler to do this, hence the compiler detection comes before
# this step. To detect the linear algebra routines we need to have worked out
# how to build code for this platform which requires detecting the 32- vs. 64-
# bit characteristics before attempting to detect the linear algebra routines.
#
if [ ${#NWCHEM_PTR_SIZE} -eq 0 ] ; then
  NWCHEM_PTR_SIZE=`get_pointer_size ${MPI_CC}`
  if [ $? -ne 0 ] ; then
    unset NWCHEM_PTR_SIZE
  fi
fi
if [ ${#NWCHEM_OS} -eq 0 ] ; then
  NWCHEM_OS=`uname | tr '[a-z]' '[A-Z]'`
  if [ $? -ne 0 ] ; then
    unset NWCHEM_OS
  fi
  if [ ${#NWCHEM_OS} -ne 0 ] ; then
    if [ ${NWCHEM_OS} == "DARWIN" ] ; then
      export NWCHEM_OS=MACX
      export BLAS_LIB=" " # At present Mac BLAS/LAPACK libraries fail for large matrices so we switch the code to use the internal implementations
      export LAPACK_LIB=" " # At present Mac BLAS/LAPACK libraries fail for large matrices so we switch the code to use the internal implementations
      echo "BLAS and LAPACK libraries for MACX fail for large matrices apparently."
      echo "Hence use internal source code for these libraries."
    elif [ ${NWCHEM_OS} == "AIX" ] ; then
      export NWCHEM_OS=IBM
    elif [ `expr match ${NWCHEM_OS} CYGWIN` != "0" ] ; then
      export NWCHEM_OS=CYGWIN
      if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
        # There is no CYGWIN64 target so set NWCHEM_TARGET here
        export NWCHEM_TARGET=${NWCHEM_OS}
      fi
      # If the user did not specify any compilers and we have not been able
      # to find them in the CYGWIN environment, then we will try and use the
      # regular GNU compilers
      if [ ${#MPI_F90} -eq 0 ] ; then
        export MPI_F90=gfortran
      fi
      if [ ${#MPI_CC} -eq 0 ] ; then
        export MPI_CC=gcc
      fi
      if [ ${#MPI_CXX} -eq 0 ] ; then
        export MPI_CXX=gCC
      fi
      # I am not aware of any MPI implementations for CYGWIN so we assume to
      # be using TCGMSG.
      if [ ${#MSG_COMMS} -eq 0 ] ; then
        export MSG_COMMS=TCGMSG
      fi
    elif [ `expr match ${NWCHEM_OS} CYGNUS` != "0" ] ; then
      export NWCHEM_OS=CYGNUS
      if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
        # There is no CYGNUS64 target so set NWCHEM_TARGET here
        export NWCHEM_TARGET=${NWCHEM_OS}
      fi
    elif [ `expr match ${NWCHEM_OS} INTERIX` != "0" ] ; then
      export NWCHEM_OS=INTERIX
      if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
        # There is no INTERIX64 target so set NWCHEM_TARGET here
        export NWCHEM_TARGET=${NWCHEM_OS}
      fi
    fi
  fi
fi
if [ ${#MSG_COMMS} -eq 0 ] ; then
  export MSG_COMMS=MPI
fi
if [ ${#USE_MPI} -ne 0 ] ; then
  if [ ${#USE_MPIF} -eq 0 ] ; then
    export USE_MPIF=y
  fi
  if [ ${#USE_MPIF4} -eq 0 ] ; then
    export USE_MPIF4=y
  fi
fi
if [ ${#NWCHEM_TARGET} -eq 0 ] ; then
  if [ ${#NWCHEM_PTR_SIZE} -eq 0 ] ; then
    echo "ERROR: could not establish pointer size needed to set NWCHEM_TARGET: aborting..."
    exit 1
  fi
  if [ ${#NWCHEM_OS} -eq 0 ] ; then
    echo "ERROR: could not establish the OS needed to set NWCHEM_TARGET: aborting..."
    exit 1
  fi
  if [ ${NWCHEM_PTR_SIZE} -eq 4 ] ; then
    export NWCHEM_TARGET=${NWCHEM_OS}
  else
    export NWCHEM_TARGET=${NWCHEM_OS}64
  fi
fi
if [ ${#OBJECT_MODE} -eq 0 ] ; then
  # On IBM machines we need to set what kind of executable we want, 
  # 32 or 64 bit. The default is typically 32 bit.
  if   [ "x${NWCHEM_TARGET}" == "xIBM" ] ; then
    export OBJECT_MODE=32
  elif [ "x${NWCHEM_TARGET}" == "xIBM64" ] ; then
    export OBJECT_MODE=64
  elif [ "x${NWCHEM_TARGET}" == "xLAPI" ] ; then
    export OBJECT_MODE=32
  elif [ "x${NWCHEM_TARGET}" == "xLAPI64" ] ; then
    export OBJECT_MODE=64
  fi
fi
#
# Find out whether there are any BLAS, LAPACK and/or ScaLAPACK libraries 
# available.
#
# If BLASOPT is set that runs shot over everything. 
#
if [ ${#BLASOPT} -ne 0 ] ; then
  DUMMY=`get_blas_lib ${MPI_F90} "${BLASOPT}"`
  result=$?
  if [ ${result} -eq 0 ] ; then
    export BLAS_LIB="${BLASOPT}"
  else 
    # BLASOPT set but no BLAS available so use internal BLAS library
    export BLAS_LIB=" "
  fi
  DUMMY=`get_lapack_lib ${MPI_F90} "${BLASOPT}" "${BLASOPT}"`
  result=$?
  if [ ${result} -eq 0 ] ; then
    export LAPACK_LIB="${BLASOPT}"
  else 
    # BLASOPT set but no LAPACK available so use internal LAPACK library
    export LAPACK_LIB=" "
  fi
  if [ ${#MPI_LIB} -ne 0 ] ; then
    # Only set MPI_LIB_TMP if MPI_LIB is non-empty
    MPI_LIB_TMP=`echo "-L${MPI_LIB}" | sed 's/^-L-L/-L/'`
  fi
  DUMMY=`get_scalapack_lib ${MPI_F90} "${BLASOPT} ${MPI_LIB_TMP} ${LIBMPI}" "${BLASOPT}"`
  result=$?
  if [ ${result} -eq 0 ] ; then
    export SCALAPACK_LIB="${BLASOPT}"
  else
    # BLASOPT set but no ScaLAPACK available so suppress ScaLAPACK library
    export SCALAPACK_LIB=" "
  fi
fi
#
# If needed find libraries and work out which integer types they support
#
if [ ${#BLAS_LIB} -eq 0 ] ; then
  BLAS_LIB=`get_blas_lib ${MPI_F90} 0`
  export BLAS_LIB
fi
if [ ${#BLAS_SIZE} -eq 0 ] ; then
  if [ ${#BLAS_LIB} -eq 0 ] ; then
    # In this case we will build the BLAS from source
    BLAS_SIZE=8
  else
    BLAS_SIZE=`get_blas_integer ${MPI_F90} "${BLAS_LIB}"`
    if [ $? -ne 0 ] ; then
      BLAS_SIZE=8
    fi
  fi
  export BLAS_SIZE
fi
if [ ${#LAPACK_LIB} -eq 0 ] ; then
  LAPACK_LIB=`get_lapack_lib ${MPI_F90} "${BLAS_LIB}" 0`
  export LAPACK_LIB
fi
if [ ${#LAPACK_SIZE} -eq 0 ] ; then
  if [ ${#LAPACK_LIB} -eq 0 ] ; then
    # In this case we will build the LAPACK from source
    LAPACK_SIZE=8
  else
    LAPACK_SIZE=`get_lapack_integer ${MPI_F90} "${LAPACK_LIB} ${BLAS_LIB}"`
    if [ $? -ne 0 ] ; then
      LAPACK_SIZE=8
    fi
  fi
  export LAPACK_SIZE
fi
if [ ${#SCALAPACK_LIB} -eq 0 ] ; then
  if [ ${#MPI_LIB} -ne 0 ] ; then
    # Only set MPI_LIB_TMP if MPI_LIB is non-empty
    MPI_LIB_TMP=`echo "-L${MPI_LIB}" | sed 's/^-L-L/-L/'`
  fi
  SCALAPACK_LIB=`get_scalapack_lib ${MPI_F90} "${LAPACK_LIB} ${BLAS_LIB} ${MPI_LIB_TMP} ${LIBMPI}" 0`
  export SCALAPACK_LIB
fi
if [ ${#SCALAPACK_SIZE} -eq 0 ] ; then
  if [ ${#SCALAPACK_LIB} -eq 0 ] ; then
    # In this case there is no ScaLAPACK
    SCALAPACK_SIZE=0
  else
    if [ ${#MPI_LIB} -ne 0 ] ; then
      # Only set MPI_LIB_TMP if MPI_LIB is non-empty
      MPI_LIB_TMP=`echo "-L${MPI_LIB}" | sed 's/^-L-L/-L/'`
    fi
    SCALAPACK_SIZE=`get_scalapack_integer ${MPI_F90} "${SCALAPACK_LIB} ${LAPACK_LIB} ${BLAS_LIB} ${MPI_LIB_TMP} ${LIBMPI}"`
  fi
  export SCALAPACK_SIZE
fi
#
# Check whether this machine supports GPUs
#
if [ ${#TCE_CUDA} -ne 0 ] ; then
  if [ ${#CUDA} -eq 0 ] ; then
     CUDA=`which nvcc`
     if [ ${#CUDA} -ne 0 ] ; then
       export CUDA
     else
       unset CUDA
     fi
  fi
  if [ ${#CUDA} -ne 0 ] ; then
     CUDA_PATH="`dirname ${CUDA}`"
     CUDA_PATH="`dirname ${CUDA_PATH}`"
     if [ ${#CUDA_INCLUDE} -eq 0 ] ; then
       export CUDA_INCLUDE="-I${CUDA_PATH}/include"
     fi
     if [ ${#CUDA_LIBS} -eq 0 ] ; then
       if [ ${NWCHEM_PTR_SIZE} -eq 4 ] ; then
         export CUDA_LIBS="-L${CUDA_PATH}/lib -lcudart"
       elif [ ${NWCHEM_PTR_SIZE} -eq 8 ] ; then
         export CUDA_LIBS="-L${CUDA_PATH}/lib64 -lcudart"
       else
         echo "NWCHEM_PTR_SIZE unknown; cannot set CUDA_LIBS; aborting..."
         exit 100
       fi
     fi
     unset CUDA_PATH
  fi
  # There is also a variable CUDA_FLAGS but I have no idea what that should be.
fi
#
# Work out whether BLAS, LAPACK and SCALAPACK are compatible and based on that
# what we are actually going to use.
#
echo "=== Initial guesses for linear algebra libraries ==="
echo "BLAS      = " ${BLAS_LIB} " integer-size = " ${BLAS_SIZE}
echo "LAPACK    = " ${LAPACK_LIB} " integer-size = " ${LAPACK_SIZE}
echo "SCALAPACK = " ${SCALAPACK_LIB} " integer-size = " ${SCALAPACK_SIZE}
echo "=== Working out how to proceed ====================="
if [ ${#SCALAPACK_LIB} -eq 0 ] ; then
  # No ScaLAPACK found so worry only about BLAS and LAPACK
  echo "No ScaLAPACK found, so no ScaLAPACK will be used"
  if [ ${LAPACK_SIZE} -ne ${BLAS_SIZE} ] ; then
    # So at least one of LAPACK and BLAS has to fall back to source code
    # and integer*8.
    echo "BLAS and LAPACK integer sizes do not match, dropping the integer size 4 library"
    if [[ ( ${BLAS_SIZE} -eq 4 ) || ( ${BLAS_SIZE} -eq 0 ) ]] ; then
      export BLAS_LIB=""
      export BLAS_SIZE=8
    fi
    if [[ ( ${LAPACK_SIZE} -eq 4 ) || ( ${LAPACK_SIZE} -eq 0 ) ]] ; then
      export LAPACK_LIB=""
      export LAPACK_SIZE=8
    fi
  else
    echo "BLAS and LAPACK are OK"
  fi
else
  if [[ ( ${LAPACK_SIZE} -ne ${BLAS_SIZE} ) || ( ${SCALAPACK_SIZE} -ne ${BLAS_SIZE} ) ]] ; then
    echo "BLAS, LAPACK and ScaLAPACK integer sizes do not match, dropping the integer size 4 libraries"
    if [[ ( ${BLAS_SIZE} -eq 4 ) || ( ${BLAS_SIZE} -eq 0 ) ]] ; then
      export BLAS_LIB=""
      export BLAS_SIZE=8
    fi
    if [[ ( ${LAPACK_SIZE} -eq 4 ) || ( ${LAPACK_SIZE} -eq 0 ) ]] ; then
      export LAPACK_LIB=""
      export LAPACK_SIZE=8
    fi
    if [[ ( ${SCALAPACK_SIZE} -eq 4 ) || ( ${SCALAPACK_SIZE} -eq 0 ) ]] ; then
      export SCALAPACK_LIB=""
      export SCALAPACK_SIZE=8
    fi
  else
    echo "BLAS, LAPACK and ScaLAPACK are OK"
  fi
fi
if [ "${BLAS_LIB}" == " " ] ; then
  export BLAS_LIB=""
fi
if [ "${LAPACK_LIB}" == " " ] ; then
  export LAPACK_LIB=""
fi
if [ "${SCALAPACK_LIB}" == " " ] ; then
  export SCALAPACK_LIB=""
fi
if [ ${#SCALAPACK_LIB} -ne 0 ] ; then
  export USE_SCALAPACK=y
fi
if [ ${#NWCHEM_EXECUTABLE} -eq 0 ] ; then
  export NWCHEM_EXECUTABLE=$NWCHEM_TOP/bin/$NWCHEM_TARGET/nwchem
fi
if [ "x$1" == "xpython" ]; then
  export PYTHONVERSION=2.4
  export PYTHONHOME=/usr
  export PYTHONPATH=./:$NWCHEM_TOP/contrib/python/
  export NWCHEM_MODULES="$NWCHEM_MODULES python"
  echo "===================================="
  echo "Building NWChem including Python $PYTHONVERSION"
  echo "===================================="
  echo
  option=""
elif [ "x$1" == "xpython64" ]; then
  export USE_PYTHON64=yes
  export PYTHONVERSION=2.4
  export PYTHONHOME=/usr
  export PYTHONPATH=./:$NWCHEM_TOP/contrib/python/
  export NWCHEM_MODULES="$NWCHEM_MODULES python"
  echo "===================================="
  echo "Building NWChem including Python $PYTHONVERSION"
  echo "===================================="
  echo
  option=""
else
  echo "==============="
  echo "Building NWChem"
  echo "==============="
  echo
fi
echo "NWCHEM_TOP     =" ${NWCHEM_TOP}
echo "NWCHEM_TARGET  =" ${NWCHEM_TARGET}
echo "NWCHEM_MODULES =" ${NWCHEM_MODULES}
if [ ${#OBJECT_MODE} -ne 0 ] ; then
  echo "OBJECT_MODE    =" ${OBJECT_MODE}
fi
echo "USE_MPI        =" ${USE_MPI}
if [ ${#USE_MPIF} -ne 0 ] ; then
  echo "USE_MPIF       =" ${USE_MPIF}
fi
if [ ${#USE_MPIF4} -ne 0 ] ; then
  echo "USE_MPIF4      =" ${USE_MPIF4}
fi
echo "MPI_INCLUDE    =" ${MPI_INCLUDE}
echo "MPI_LIB        =" ${MPI_LIB}
echo "LIBMPI         =" ${LIBMPI}
echo "MPI_F90        =" ${MPI_F90}
echo "MPI_CC         =" ${MPI_CC}
echo "MPI_CXX        =" ${MPI_CXX}
echo "ARMCI_NETWORK  =" ${ARMCI_NETWORK}
echo "MSG_COMMS      =" ${MSG_COMMS}
if [ ${#IB_INCLUDE} -ne 0 ] ; then
  echo "IB_INCLUDE     =" ${IB_INCLUDE}
fi
if [ ${#IB_LIB} -ne 0 ] ; then
  echo "IB_LIB         =" ${IB_LIB}
fi
if [ ${#IB_LIB_NAME} -ne 0 ] ; then
  echo "IB_LIB_NAME    =" ${IB_LIB_NAME}
fi
if [ ${#BLASOPT} -ne 0 ] ; then
  echo "BLASOPT        =" ${BLASOPT} 
fi
if [ ${#BLAS_LIB} -ne 0 ] ; then
  echo "BLAS_LIB       =" ${BLAS_LIB} " integer-size = " ${BLAS_SIZE}
fi
if [ ${#LAPACK_LIB} -ne 0 ] ; then
  echo "LAPACK_LIB     =" ${LAPACK_LIB} " integer-size = " ${LAPACK_SIZE}
fi
if [ ${#SCALAPACK_LIB} -ne 0 ] ; then
  echo "SCALAPACK_LIB  =" ${SCALAPACK_LIB} " integer-size = " ${SCALAPACK_SIZE}
fi
if [ ${#CUDA} -ne 0 ] ; then
  echo "CUDA           =" ${CUDA}
fi
if [ ${#CUDA_INCLUDE} -ne 0 ] ; then
  echo "CUDA_INCLUDE   =" ${CUDA_INCLUDE}
fi
if [ ${#CUDA_LIBS} -ne 0 ] ; then
  echo "CUDA_LIBS      =" ${CUDA_LIBS}
fi
if [ ${#MRCC_METHODS} -ne 0 ] ; then
  echo "MRCC_METHODS   =" ${MRCC_METHODS}
fi
#
# Stop if we find essential information missing.
# I.e. no Fortran, C, or C++ compilers or settings to use obsolete versions
# of GA.
#
if [ ${#MPI_F90} -eq 0 ] ; then
  echo "ERROR: No Fortran compiler found: aborting..." > /dev/stderr
  exit 1
fi
if [ ${#MPI_CC} -eq 0 ] ; then
  echo "ERROR: No C compiler found: aborting..." > /dev/stderr
  exit 1
fi
if [ ${#MPI_CXX} -eq 0 ] ; then
  echo "ERROR: No C++ compiler found: aborting..." > /dev/stderr
  exit 1
fi
if [ "`basename ${MPI_F90}`" != "${MPI_F90}" ] ; then
  echo "ERROR: Fortran compiler has to be the basename: ${MPI_F90}" > /dev/stderr
  echo "ERROR: Invalid Fortran compiler: aborting..." > /dev/stderr
  exit 1
fi
if [ "`basename ${MPI_CC}`" != "${MPI_CC}" ] ; then
  echo "ERROR: C compiler has to be the basename: ${MPI_CC}" > /dev/stderr
  echo "ERROR: Invalid C compiler: aborting..." > /dev/stderr
  exit 1
fi
if [ "`basename ${MPI_CXX}`" != "${MPI_CXX}" ] ; then
  echo "ERROR: C++ compiler has to be the basename: ${MPI_CXX}" > /dev/stderr
  echo "ERROR: Invalid C++ compiler: aborting..." > /dev/stderr
  exit 1
fi
if [ ${#MRCC_METHODS} -ne 0 ] ; then
  if [[ ( ${NWCHEM_MODULES} != "all" ) &&
        ( ${NWCHEM_MODULES} != "pnnl" ) &&
        ( ${NWCHEM_MODULES} != "alldev" ) &&
        ( ${NWCHEM_MODULES} != "pnnldev" ) ]] ; then
    echo "ERROR: The MRCC methods cannot be used with the NWCHEM_MODULES selection: ${NWCHEM_MODULES}" > /dev/stderr
    echo "ERROR: Conflicting MRCC and NWCHEM_MODULES selection: aborting..." > /dev/stderr
    exit 1
  fi
fi

if [ ${#OLD_GA} -ne 0 ] ; then
  cd contrib/mapointer_test
  ./fix_include_files
  cd ../..
fi
cd $NWCHEM_TOP/src
echo "=== configure GA ==="
if [ ${#OLD_GA} -eq 0 ] ; then
  if [ "x${option}" != "xrealclean" ]; then
    make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" configure_ga
    #
    # Extract information about BLAS libraries from the GA config.status file
    #
    have_blas_false=`get_config_value "HAVE_BLAS_FALSE"`
    have_blas_true=`get_config_value "HAVE_BLAS_TRUE"`
    if [ "x${have_blas_true}" == "x" ] ; then
      if [ "x${have_blas_false}" == "x#" ] ; then
        # The GA found some BLAS library, set GA_BLAS accordingly
        GA_BLAS=`get_config_value "BLAS_LDFLAGS"`
        GA_BLAS="${GA_BLAS} `get_config_value \"BLAS_LIBS\"`"
        GA_BLAS_SIZE=`get_config_value "BLAS_SIZE"`
        export GA_BLAS
        if [ ${#BLAS_SIZE} -ne 0 ] ; then
          if [ "${BLAS_SIZE}" != "${GA_BLAS_SIZE}" ] ; then
            echo "Warning: BLAS_SIZE and GA_BLAS_SIZE do not match " ${BLAS_SIZE} ${GA_BLAS_SIZE}
            export GA_BLAS_SIZE=${BLAS_SIZE}
          fi
        fi
        if [ "${GA_BLAS_SIZE}" == "4" ] ; then
          export USE_64TO32=y
        else
          unset USE_64TO32
        fi
        echo "Found BLAS " ${GA_BLAS}
        echo "Found BLAS type: integer*"${GA_BLAS_SIZE}
      else
        # Confused
        echo "ERROR: A: inconsistent data on presence of BLAS library"
        echo "have_blas_true  = " ${have_blas_true}
        echo "have_blas_false = " ${have_blas_false}
        exit 1
      fi
    elif [ "x${have_blas_true}" == "x#" ] ; then
      if [ "x${have_blas_false}" == "x" ] ; then
        # The GA found no BLAS library, unset GA_BLAS to maintain consistency
        unset GA_BLAS
        echo "Found no BLAS "
      else
        # Confused
        echo "ERROR: B: inconsistent data on presence of BLAS library"
        echo "have_blas_true  = " ${have_blas_true}
        echo "have_blas_false = " ${have_blas_false}
        exit 1
      fi
    else
      echo "ERROR: C: invalid settings" 
      echo "have_blas_true  = " ${have_blas_true}
      echo "have_blas_false = " ${have_blas_false}
      exit 1
    fi
    #
    # Extract information about LAPACK libraries from the GA config.status file
    #
    have_lapack_false=`get_config_value "HAVE_LAPACK_FALSE"`
    have_lapack_true=`get_config_value "HAVE_LAPACK_TRUE"`
    if [ "x${have_lapack_true}" == "x" ] ; then
      if [ "x${have_lapack_false}" == "x#" ] ; then
        # The GA found some LAPACK library, set GA_LAPACK accordingly
        GA_LAPACK=`get_config_value "LAPACK_LDFLAGS"`
        GA_LAPACK="${GA_LAPACK} `get_config_value \"LAPACK_LIBS\"`"
        GA_LAPACK_SIZE=`get_config_value "LAPACK_SIZE"`
        export GA_LAPACK
        if [ ${#LAPACK_SIZE} -ne 0 ] ; then
          if [ "${LAPACK_SIZE}" != "${GA_LAPACK_SIZE}" ] ; then
            echo "Warning: LAPACK_SIZE and GA_LAPACK_SIZE do not match " ${LAPACK_SIZE} ${GA_LAPACK_SIZE}
            export GA_LAPACK_SIZE=${LAPACK_SIZE}
          fi
        fi
        if [ "${GA_LAPACK_SIZE}" == "4" ] ; then
          export USE_64TO32=y
        else
          unset USE_64TO32
        fi
        echo "Found LAPACK " ${GA_LAPACK}
        echo "Found LAPACK type: integer*"${GA_LAPACK_SIZE}
      else
        # Confused
        echo "ERROR: A: inconsistent data on presence of LAPACK library"
        echo "have_lapack_true  = " ${have_lapack_true}
        echo "have_lapack_false = " ${have_lapack_false}
        exit 1
      fi
    elif [ "x${have_lapack_true}" == "x#" ] ; then
      if [ "x${have_lapack_false}" == "x" ] ; then
        # The GA found no LAPACK library, unset GA_LAPACK to maintain consistency
        unset GA_LAPACK
        echo "Found no LAPACK "
      else
        # Confused
        echo "ERROR: B: inconsistent data on presence of LAPACK library"
        echo "have_lapack_true  = " ${have_lapack_true}
        echo "have_lapack_false = " ${have_lapack_false}
        exit 1
      fi
    else
      echo "ERROR: C: invalid settings" 
      echo "have_lapack_true  = " ${have_lapack_true}
      echo "have_lapack_false = " ${have_lapack_false}
      exit 1
    fi
    #
    # Extract information about SCALAPACK libraries from the GA config.status file
    #
    have_scalapack_false=`get_config_value "HAVE_SCALAPACK_FALSE"`
    have_scalapack_true=`get_config_value "HAVE_SCALAPACK_TRUE"`
    if [ "x${have_scalapack_true}" == "x" ] ; then
      if [ "x${have_scalapack_false}" == "x#" ] ; then
        # The GA found some SCALAPACK library, set GA_SCALAPACK accordingly
        GA_SCALAPACK=`get_config_value "SCALAPACK_LDFLAGS"`
        GA_SCALAPACK="${GA_SCALAPACK} `get_config_value \"SCALAPACK_LIBS\"`"
        GA_SCALAPACK_SIZE=`get_config_value "SCALAPACK_SIZE"`
        export GA_SCALAPACK
        if [ ${#SCALAPACK_SIZE} -ne 0 ] ; then
          if [ "${SCALAPACK_SIZE}" != "${GA_SCALAPACK_SIZE}" ] ; then
            echo "Warning: SCALAPACK_SIZE and GA_SCALAPACK_SIZE do not match " ${SCALAPACK_SIZE} ${GA_SCALAPACK_SIZE}
            export GA_SCALAPACK_SIZE=${SCALAPACK_SIZE}
          fi
        fi
        if [ "${GA_SCALAPACK_SIZE}" == "4" ] ; then
          export USE_64TO32=y
        else
          unset USE_64TO32
        fi
        echo "Found SCALAPACK " ${GA_SCALAPACK}
        echo "Found SCALAPACK type: integer*"${GA_SCALAPACK_SIZE}
      else
        # Confused
        echo "ERROR: A: inconsistent data on presence of SCALAPACK library"
        echo "have_scalapack_true  = " ${have_scalapack_true}
        echo "have_scalapack_false = " ${have_scalapack_false}
        exit 1
      fi
    elif [ "x${have_scalapack_true}" == "x#" ] ; then
      if [ "x${have_scalapack_false}" == "x" ] ; then
        # The GA found no SCALAPACK library, unset GA_SCALAPACK to maintain consistency
        unset GA_SCALAPACK
        echo "Found no SCALAPACK "
      else
        # Confused
        echo "ERROR: B: inconsistent data on presence of SCALAPACK library"
        echo "have_scalapack_true  = " ${have_scalapack_true}
        echo "have_scalapack_false = " ${have_scalapack_false}
        exit 1
      fi
    else
      echo "ERROR: C: invalid settings" 
      echo "have_scalapack_true  = " ${have_scalapack_true}
      echo "have_scalapack_false = " ${have_scalapack_false}
      exit 1
    fi
  fi
  if [ ${#BLASOPT} -eq 0 ] ; then
    if [ ${#GA_SCALAPACK} -ne 0 ] ; then
      export BLASOPT="${GA_SCALAPACK}"
    fi
    if [ ${#GA_LAPACK} -ne 0 ] ; then
      export BLASOPT="${BLASOPT} ${GA_LAPACK}"
    fi
    if [ ${#GA_BLAS} -ne 0 ] ; then
      export BLASOPT="${BLASOPT} ${GA_BLAS}"
    fi
    echo "BLASOPT from GA = " ${BLASOPT}
  fi
fi
echo "=== before    NWChem ==="
echo "BLASOPT =" ${BLASOPT}
echo "=== configure NWChem ==="
if [ "x${option}" != "xrealclean" ]; then
  make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" nwchem_config
fi
cd $NWCHEM_TOP/src/util
echo "=== build NWChem version table ==="
if [ "x${option}" != "xrealclean" ]; then
  if [ ${#NWCHEM_VERSION} -ne 0 ] ; then
    make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" version
  else
    rm -f util_version.F
  fi
fi
cd $NWCHEM_TOP/src
echo "=== do NWChem code conversion ==="
if [ "x${option}" != "xrealclean" ]; then
  #
  # For some reason a Fortran compiler must be specified (even though none is
  # used in the code conversion) otherwise an error message is generated and
  # corresponding make operation fails.
  #
  make FC=$MPI_F90 directories
  if [ ${#USE_64TO32} -eq 0 ] ; then
     make FC=$MPI_F90 32_to_64
  else
     make FC=$MPI_F90 64_to_32
  fi
  #
  # The make 32_to_64 or 64_to_32 forced the dependencies to be created
  # However, at this time the Global Arrays have not been built yet and
  # therefore the nwchem/src/tools/install/include directory does not exist,
  # and hence the GA include files cannot be successfully located. As a result
  # all the dependencies involving GA include files are bogus and wrong.
  # So delete the time stamps that protect these dependencies so that new
  # dependencies can be recorded at the right moment in the following make.
  #
  if [[ ! ( -d $NWCHEM_TOP/src/tools/install/include || \
            -d $NWCHEM_TOP/src/tools/include ) ]] ; then
    find . -name include_stamp -exec rm -f {} \; -print
    find . -name dependencies -exec rm -f {} \; -print
  fi
fi
echo "=== compile nwchem ==="
make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" $option
cd $NWCHEM_TOP/contrib/mov2asc
make DIAG=PAR FC=$MPI_F90 CC=$MPI_CC CXX=$MPI_CXX LDOPTIONS="$LDOPTIONS" $option
echo "=== all done ==="
